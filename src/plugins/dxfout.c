/*!
 * \file dxfout.c
 * \author Copyright (C) 2010 by Bert Timmerman <bert.timmerman@xs4all.nl>
 * \brief Plug-in for PCB to export specified elements to a dxf file as
 * XREFs.
 *
 * Compile like this:\n
 * \n
 * gcc -Ipath/to/pcb/src -Ipath/to/pcb -O2 -shared dxfout.c -o dxfout.so
 * \n\n
 * The resulting dxfout.so file should go in $HOME/.pcb/plugins/\n
 * \n
 * \warning Be very strict in compiling this plug-in against the exact pcb
 * sources you compiled/installed the pcb executable (i.e. src/pcb) with.\n
 *
 * Usage: DxfoutElement(Refdes)\n
 * Usage for lazy users: DxfoutE(Refdes)\n
 * Usage for spoiled and lazy users: DE(Refdes)\n
 * If no argument is passed, no action is carried out.\n
 * \n
 * <hr>
 * This program is free software; you can redistribute it and/or modify\n
 * it under the terms of the GNU General Public License as published by\n
 * the Free Software Foundation; either version 2 of the License, or\n
 * (at your option) any later version.\n
 * \n
 * This program is distributed in the hope that it will be useful,\n
 * but WITHOUT ANY WARRANTY; without even the implied warranty of\n
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.\n
 * \n
 * You should have received a copy of the GNU General Public License\n
 * along with this program; if not, write to:\n
 * the Free Software Foundation, Inc.,\n
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n
 */


#include <stdio.h>
#include <math.h>
#include <time.h>

#include "global.h"
#include "data.h"
#include "hid.h"
#include "misc.h"
#include "create.h"
#include "rtree.h"
#include "undo.h"
#include "set.h"
#include "error.h"


/*!
 * \brief Dxf X-coordinate (in mil).
 */
#define DXF_X(pcb, x) ((long) ((x) / 100))

/*!
 * \brief Dxf Y-coordinate (in mil).
 */
#define DXF_Y(pcb, y) ((long) (((pcb)->MaxHeight - (y))) / 100)

/*!
 * \brief Dxf X offset (in mil).
 */
#define DXF_XOffset(pcb, x) ((long) ((x) / 100))

/*!
 * \brief Dxf Y offset (in mil).
 */
#define DXF_YOffset(pcb, y) ((long) (-(y) / 100))

/*!
 * \brief Round of value to the nearest multiple of 100.
 */
#define DXF_ROUND(x) ((int)(((x) + 50) / 100) * 100)

/*!
 * \brief There is <b>always</b> a layer "0" defined, so it's reasonably
 * safe to assume that this is a valid layername.
 */
#define DXF_DEFAULT_LAYER "0"

/*!
 * \brief This is where our hardware is going to live, default value,
 * can be ommitted in dxf output.
 */
#define DXF_MODELSPACE 0

/*!
 * \brief This is where your annotation (papersheet templates, fab notes
 * and such) should live, has to be included in DXF output for any
 * entity to live on paperspace.
 */
#define DXF_PAPERSPACE 1

/*!
 * \brief There is <b>always</b> a linetype "BYLAYER" defined, so it's
 * reasonably safe to assume that this is a valid linetype.
 */
#define DXF_DEFAULT_LINETYPE "BYLAYER"

/*!
 * \brief DXF color definition, entities with this color follow the color
 * definition of the block in which it lives.
 */
#define DXF_COLOR_BYBLOCK 0

/*!
 * \brief DXF color definition, pen number "1" in the virtual pen-plotter.
 */
#define DXF_COLOR_RED 1

/*!
 * \brief DXF color definition, pen number "2" in the virtual pen-plotter.
 */
#define DXF_COLOR_YELLOW 2

/*!
 * \brief DXF color definition, pen number "3" in the virtual pen-plotter.
 */
#define DXF_COLOR_GREEN 3

/*!
 * \brief DXF color definition, pen number "4" in the virtual pen-plotter.
 */
#define DXF_COLOR_CYAN 4

/*!
 * \brief DXF color definition, pen number "5" in the virtual pen-plotter.
 */
#define DXF_COLOR_BLUE 5

/*!
 * \brief DXF color definition, pen number "6" in the virtual pen-plotter.
 */
#define DXF_COLOR_MAGENTA 6

/*!
 * \brief DXF color definition, pen number "7" in the virtual pen-plotter.
 */
#define DXF_COLOR_WHITE 7

/*!
 * \brief DXF color definition, pen number "8" in the virtual pen-plotter.
 */
#define DXF_COLOR_GREY 8

/*!
 * \brief DXF color definition, color of the entity follows the color
 * definition of the layer on which it lives.
 */
#define DXF_COLOR_BYLAYER 256

/*!
 * \brief This is an anonymous Block generated by hatching,
 * associative dimensioning, other internal operations, or an
 * application.
 */
#define DXF_BLOCK_IS_ANONYMOUS 1

/*!
 * \brief This Block has Attributes.
 */
#define DXF_BLOCK_HAS_ATTRIBUTES 2

/*!
 * \brief This Block is an external reference (XREF).
 */
#define DXF_BLOCK_IS_XREF 4

/*!
 * \brief This Block is externally dependent.
 */
#define DXF_BLOCK_IS_EXTERNALLY_DEPENDENT 16

/*!
 * \brief This is a resolved external reference, or dependent of an
 * external reference.
 */
#define DXF_BLOCK_IS_RESOLVED_XREF 32

/*!
 * \brief This B/block definition is referenced.
 */
#define DXF_BLOCK_IS_REFERENCED 64

/*!
 * \brief Directory where 3D models of parts live.
 *
 * For now the dxf_xref_pathname is set to "parts", in AutoCAD one can
 * configure default search directories for xrefs.
 */
#define DXF_DEFAULT_XREF_PATH_NAME "parts"


/*!
 * \brief Directory separator character (back slash).
 *
 * For now we live in a micro$oft & Autodesk universe with all of their
 * quirks.
 *
 * \todo This has to be solved in a more elegant manner if we want to
 * use DXF file on *nix based CAD software.
 */
#define DXF_DIR_SEPARATOR "\\"


/*!
 * \brief DXF file with verbose output (to contain DXF comments).
 */
static int dxf_verbose;


/*!
 * \brief Write DXF output to a file for a block entity.
 *
 *The <c>BLOCKS</c> section of the DXF file contains all the block
 * definitions.\n
 * It contains the entities that make up the blocks used in the drawing,
 * including anonymous blocks generated by the HATCH command and by
 * associative dimensioning.\n
 * The format of the entities in this section is identical to those in
 * the <c>ENTITIES</c> section.\n
 * All entities in the <c>BLOCKS</c> section appear between block and
 * endblk entities.\n
 * Block and endblk entities appear only in the <c>BLOCKS</c> section.\n
 * Block definitions are never nested (that is, no block or endblk
 * entity ever appears within another block-endblk pair), although a
 * block definition can contain an insert entity.\n
 * \n
 * External references are written in the DXF file as block definitions,
 * except that they also include a string (group code 1) that specifies
 * the path and file name of the external reference.\n
 * \n
 * The block table handle, along with any xdata and persistent reactors,
 * appears in each block definition immediately following the
 * <c>BLOCK</c> record, which contains all of the specific information
 * that a block table record stores.\n
 * \n
 * The UCS in effect when a block definition is created becomes the WCS
 * for all entities in the block definition.\n
 * The new origin for these entities is shifted to match the base point
 * defined for the block definition.\n
 * All entity data is translated to fit this new WCS.\n
 * \n
 * <c>*MODEL_SPACE</c> and <c>*PAPER_SPACE</c> Block Definition.\n
 * Now, there are always two extra, empty definitions in the BLOCKS
 * section, titled <c>*MODEL_SPACE</c> and <c>*PAPER_SPACE</c>.\n
 * These definitions manifest the new representation of model space and
 * paper space as block definitions internally.\n
 * The entities contained in these definitions still appear in the
 * <c>ENTITIES</c> section for compatibility.\n
 * \n
 * Model Space and Paper Space Entity Segregation.\n
 * The interleaving between model space and paper space will no longer
 * occurs, because of internal organization.\n
 * Instead, all paper space entities are output, followed by model space
 * entities.\n
 * The flag distinguishing them is the group code 67.\n
 *
 * \todo Add group code 102 stuff.
 */
static void
dxf_write_block
(
        FILE *fp,
                /*!< file pointer to output file (or device) */
        int id_code,
                /*!< group code = 5 */
        char *xref_name,
                /*!< group code = 1 */
        char *block_name,
                /*!< group code = 2 and 3 */
        char *linetype,
                /*!< group code = 6\n
                 * optional, if omitted defaults to BYLAYER */
        char *layer,
                /*!< group code = 8 */
        double x0,
                /*!< group code = 10\n base point */
        double y0,
                /*!< group code = 20\n base point */
        double z0,
                /*!< group code = 30\n base point */
        double thickness,
                /*!< group code = 39\n
                 * optional, if omitted defaults to 0.0 */
        int color,
                /*!< group code = 62\n
                 * optional, if omitted defaults to BYLAYER */
        int paperspace,
                /*!< group code = 67\n
                 * optional, if omitted defaults to 0 (modelspace) */
        int block_type
                /*!< group code = 70\n
                 * bit codes:\n
                 * 1 = this is an anonymous Block generated by hatching,
                 * associative dimensioning, other internal operations, or an
                 * application\n
                 * 2 = this Block has Attributes\n
                 * 4 = this Block is an external reference (Xref)\n
                 * 8 = not used\n
                 * 16 = this Block is externally dependent\n
                 * 32 = this is a resolved external reference, or dependent
                 * of an external reference\n
                 * 64 = this definition is referenced */
)
{
#if DEBUG
        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_block () function.\n", __FILE__, __LINE__);
        fprintf (stderr, "[DXF entity with code %x]\n", id_code);
#endif
        char *dxf_entity_name = strdup ("BLOCK");
        if (strcmp (block_name, "") == 0)
        {
                if (dxf_verbose)
                {
                        fprintf (stderr, "DXF Warning: empty block name string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
                        fprintf (stderr, "\t%s entity is discarded from output.\n", dxf_entity_name);
                }
                return;
        }
        if (strcmp (xref_name, "") == 0)
        {
                if (dxf_verbose)
                {
                        fprintf (stderr, "DXF Warning: empty xref name string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
                        fprintf (stderr, "\t%s entity is discarded from output.\n", dxf_entity_name);
                }
                return;
        }
        if (strcmp (layer, "") == 0)
        {
                if (dxf_verbose)
                {
                        fprintf (stderr, "DXF Warning: empty layer string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
                        fprintf (stderr, "\t%s entity is relocated to layer 0.\n", dxf_entity_name);
                }
                layer = strdup (DXF_DEFAULT_LAYER);
        }
        fprintf (fp, "  0\n%s\n", dxf_entity_name);
        if (id_code != -1)
        {
                fprintf (fp, "  5\n%x\n", id_code);
        }
        /* group code 102 stuff goes here  */
        fprintf (fp, "100\nAcDbEntity\n");
        fprintf (fp, "  8\n%s\n", layer);
        fprintf (fp, "100\nAcDbBlockBegin\n");
        fprintf (fp, "  2\n%s\n", block_name);
        fprintf (fp, " 70\n%d\n", block_type);
        fprintf (fp, " 10\n%f\n", x0);
        fprintf (fp, " 20\n%f\n", y0);
        fprintf (fp, " 30\n%f\n", z0);
        fprintf (fp, "  3\n%s\n", block_name);
        if ((block_type && 4) || (block_type && 32))
        {
                fprintf (fp, "  1\n%s%s%s.dwg\n", xref_name, DXF_DIR_SEPARATOR, block_name);
        }
//        if (strcmp (linetype, DXF_DEFAULT_LINETYPE) != 0) fprintf (fp, "  6\n%s\n", linetype);
//        if (thickness != 0.0) fprintf (fp, " 39\n%f\n", thickness);
//        if (color != DXF_COLOR_BYLAYER) fprintf (fp, " 62\n%d\n", color);
        if (paperspace == DXF_PAPERSPACE)
        {
                fprintf (fp, " 67\n%d\n", DXF_PAPERSPACE);
        }
        /* now write an end block marker */
        fprintf (fp, "  0\nENDBLK\n");
        if (id_code != -1)
        {
                fprintf (fp, "  5\n%x\n", id_code);
        }
        /* group code 102 stuff goes here */
        fprintf (fp, "100\nAcDbBlockEnd\n");
#if DEBUG
        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_block () function.\n", __FILE__, __LINE__);
#endif
}


/*!
 * \brief Export the specified elements.
 *
 * Usage: DxfoutElement(Refdes)\n
 * Usage for lazy users: DxfoutE(Refdes)\n
 * Usage for spoiled and lazy users: DE(Refdes)\n
 * If no argument is passed, no action is carried out.
 */
static int
dxfout_element (int argc, char **argv, int x, int y)
{
        int i;
        char utcTime[64];
        FILE *fp;
        char *dxfout_xref_filename = NULL;
        bool dxfout_metric;
        
        /*! \todo Implement the choice for metric or imerial units. */
        dxfout_metric = true;
        if (argc == 0 || strcasecmp (argv[0], "") == 0)
        {
                Message ("WARNING: in DxfoutElement the argument should be a non-empty string value.\n");
                return 0;
        }
        else
        {
                SET_FLAG (NAMEONPCBFLAG, PCB);
                i = strlen (PCB->Filename);
                dxfout_xref_filename = MyRealloc (dxfout_xref_filename, i + 40, "dxf");
                dxfout_xref_filename = PCB->Filename;
                if (!dxfout_xref_filename)
                {
                        strcat (dxfout_xref_filename, "dxfout_xrefs.dxf");
                }
                strcat (dxfout_xref_filename, "_xrefs.dxf");
                fp = fopen (dxfout_xref_filename, "w");
                if (!fp)
                {
                        gui->log ("ERROR: dxfout_element (): cannot open file %s for writing.\n",
                                dxfout_xref_filename);
                        return 1;
                }
                /* Create a portable timestamp. */
                time_t currenttime;
                currenttime = time (NULL);
                strftime (utcTime, sizeof (utcTime),
                        "%c UTC", gmtime (&currenttime));
                /* Print a report when beginning a new file */
                fprintf (stderr, "DXFOUT: board name: %s, stored as file named: %s \n",
                        UNKNOWN (PCB->Name),
                        UNKNOWN (PCB->Filename));
                /*! \todo Find VERSION. */
                //fprintf (stderr, "DXFOUT: file created by: pcb-%s.\n", VERSION);
                fprintf (stderr, "DXFOUT: creation date: %s \n", utcTime);
                fprintf (stderr, "DXFOUT: file format according to: AutoCAD R14.\n");
                if (dxfout_metric)
                {
                        fprintf (stderr, "DXFOUT: using Metric coordinates [mm].\n");
                }
                else
                {
                        fprintf (stderr, "DXFOUT: using Imperial coordinates [mil].\n");
                }
                fprintf (stderr, "DXFOUT: pcb dimensions: %d %d.\n",
                        PCB->MaxWidth,
                        PCB->MaxHeight);
                fprintf (stderr, "DXFOUT: XREF coordinate origin for pcb is lower left corner.\n");
                fprintf (stderr, "DXFOUT: writing XREFs.\n");
                /* Walk all the elements. */
                ELEMENT_LOOP(PCB->Data);
                {
                        if (NAMEONPCB_NAME(element)
                                && strcmp (argv[0], NAMEONPCB_NAME(element)) == 0)
                        {
                                /*! \todo Add code here. */
                        }
                }
                END_LOOP;
                fclose (fp);
                gui->invalidate_all ();
                IncrementUndoSerialNumber ();
                return 0;
        };
}


static HID_Action dxfout_action_list[] =
{
        {"DxfoutElement", NULL, dxfout_element, "Export the specified element", NULL},
        {"DxfoutE", NULL, dxfout_element, "Export the specified element", NULL},
        {"DE", NULL, dxfout_element, "Export the specified element", NULL}
};


REGISTER_ACTIONS (dxfout_action_list)


void
pcb_plugin_init()
{
        register_dxfout_action_list();
}


/* EOF */
